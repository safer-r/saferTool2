% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/permut.R
\name{permut}
\alias{permut}
\title{permut}
\usage{
permut(
  data1,
  data2 = NULL,
  n = NULL,
  seed = NULL,
  print.count = 10,
  text.print = "",
  cor.method = "spearman",
  cor.limit = 0.2,
  warn.print = FALSE,
  lib.path = NULL
)
}
\arguments{
\item{data1}{A vector of at least 2 elements. Must be numeric if data2 is specified.}

\item{data2}{A numeric vector of same length as data1.}

\item{n}{Single numeric value of times "flipping 2 randomly selected consecutive positions". Ignored if data2 is specified.}

\item{seed}{Single integer number used by set.seed(). Write NULL if random result is required, an integer otherwise. BEWARE: if not NULL, permut() will systematically return the same result when the other parameters keep the same settings.}

\item{print.count}{Single integer value. Print a working progress message every print.count during loops. BEWARE: can increase substentially the time to complete the process using a small value, like 10 for instance. Use Inf is no loop message desired.}

\item{text.print}{Single character string indicating the optional message to add to the working progress message every print.count loop.}

\item{cor.method}{Correlation method. Either "pearson", "kendall" or "spearman". Ignored if data2 is not specified.}

\item{cor.limit}{Single positive numeric proportion fixing the correlation limit. Ignored if data2 is not specified. Compute the correlation between data1 and data2, permute the data1 values, and stop the permutation process when the correlation between data1 and data2 decreases down below the cor limit value (0.2 by default). If cor(data1, data2) is negative, then -cor.limit is used and the process stops until the correlation between data1 and data2 increases up over cor.limit (-0.2 by default). BEWARE: write a positive cor.limit even if cor(data1, data2) is known to be negative. The function will automatically uses -cor.limit. If the initial correlation is already below cor.limit (positive correlation) or over -cor.limit (negative correlation), then the data1 value positions are completely randomized (correlation between data1 and data2 is expected to be 0).}

\item{warn.print}{Single logical value. Print warnings at the end of the execution? No print if no warning messages}

\item{lib.path}{Character vector specifying the absolute pathways of the directories containing the required packages if not in the default directories. Ignored if NULL.}
}
\value{
A list containing:

- $data: the modified vector.

- $warn: potential warning messages (in case of negative correlation when data2 is specified). NULL if non warning message.

- $cor: a spearman correlation between the initial positions (1:length(data1) and the final positions if data2 is not specified and the final correlation between data1 and data2 otherwise, according to cor.method.

- $count: the number of loops used.
}
\description{
Reorder the elements of the data1 vector by flipping 2 randomly selected  consecutive positions either:

- n times (when n is precised) or.

- until the correlation between data1 and data2 decreases down to the cor.limit (0.2 by default). See cor.limit below to deal with negative correlations.

Example of consecutive position flipping: ABCD -> BACD -> BADC, etc.

Designed for discrete values, but works also for continuous values.
}
\details{
WARNINGS

see # https://www.r-bloggers.com/strategies-to-speedup-r-code/ for code speedup

The random switch of non consecutive positions (ABCD -> DBCA for instance) does not work very well as the correlation is quickly obtained but the initial vector structure is mainly kept (no much order). 

Ths code would be: pos <- ini.pos[1:2] ; pos <- sample.int(n = n , size = 2, replace = FALSE) ; tempo.pos[pos] <- tempo.pos[rev(pos)]
}
\examples{
# example (1) showing that for loop, used in permut(), is faster than while loop

ini.time <- as.numeric(Sys.time()) ; 
count <- 0 ; 
for(i0 in 1:1e9){count <- count + 1} ; 
tempo.time <- as.numeric(Sys.time()) ; 
tempo.lapse <- saferTool::round2(as.numeric(lubridate::seconds_to_period(tempo.time - ini.time))) ;
tempo.lapse

# example (2) showing that for loop, used in permut(), is faster than while loop

ini.time <- as.numeric(Sys.time()) ; 
count <- 0 ; 
while(count < 1e9){count <- count + 1} ; 
tempo.time <- as.numeric(Sys.time()) ; 
tempo.lapse <- saferTool::round2(as.numeric(lubridate::seconds_to_period(tempo.time - ini.time))) ; 
tempo.lapse

permut(data1 = LETTERS[1:5], data2 = NULL, n = 100, seed = 1, print.count = 10, text.print = "CPU NB 4")

permut(data1 = 101:110, data2 = 21:30, seed = 1, print.count = 1e4, text.print = "", cor.method = "spearman", cor.limit = 0.2)

# a way to use the cor.limit argument just considering data1

obs1 <- 101:110 ; 
permut(data1 = obs1, data2 = obs1, seed = 1, print.count = 10, cor.method = "spearman", cor.limit = 0.2)

permut(data1 = 1:10, data2 = 10:1, seed = 1, print.count = 1e6, text.print = "", cor.method = "spearman", cor.limit = 0.7)

permut(data1 = 1:10, data2 = 10:1, seed = 1, print.count = 1e3, cor.limit = 0.5)

permut(data1 = c(0,0,0,0,0), n = 5, data2 = NULL, seed = 1, print.count = 1e3, cor.limit = 0.5)
}
