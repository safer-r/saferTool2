% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slide.R
\name{slide}
\alias{slide}
\title{slide}
\usage{
slide(
  data,
  window.size,
  step,
  from = NULL,
  to = NULL,
  fun,
  args = NULL,
  boundary = "left",
  parall = FALSE,
  thread.nb = NULL,
  print.count = 100,
  res.path = NULL,
  lib.path = NULL,
  verbose = TRUE,
  safer.path =
    "C:\\\\Users\\\\Gael\\\\Documents\\\\Git_projects\\\\cute_little_R_functions\\\\cute_little_R_functions.R"
)
}
\arguments{
\item{data}{Vector, matrix, table or array of numeric values (mode must be numeric). Inf not allowed. NA will be removed before computation.}

\item{window.size}{Single numeric value indicating the width of the window sliding across data (in the same unit as data value).}

\item{step}{Single numeric value indicating the step between each window (in the same unit as data value). Cannot be larger than window.size.}

\item{from}{Single numeric value of the left boundary of the first sliding window. If NULL, min(data) is used. The first window will strictly have from or min(data) as left boundary.}

\item{to}{Single numeric value of the right boundary of the last sliding window. If NULL, max(data) is used. Warning: (1) the final last window will not necessary have to|max(data) as right boundary. In fact the last window will be the one that contains to|max(data) for the first time, i.e., min[from|min(data) + window.size + n * step >= to|max(data)]; (2) In fact, the >= in min[from|min(data) + window.size + n * step >= to|max(data)] depends on the boundary argument (>= for "right" and > for "left"); (3) to have the rule (1) but for the center of the last window, use to argument as to = to|max(data) + window.size / 2.}

\item{fun}{Function or single character string indicating the name of the function to apply in each window. Example of function: fun = mean.Example of character string: fun = "mean".}

\item{args}{Single character string of additional arguments of fun (separated by a comma between the quotes). Example args = "na.rm = TRUE" for fun = mean. Ignored if NULL.}

\item{boundary}{Either "left" or "right". Indicates if the sliding window includes values equal to left boundary and exclude values equal to right boundary ("left") or the opposite ("right").}

\item{parall}{Single logical value. Force parallelization ?}

\item{thread.nb}{Single numeric value indicating the number of threads to use if ever parallelization is required. If NULL, all the available threads will be used. Ignored if parall is FALSE.}

\item{print.count}{Single integer value. Print a working progress message every print.count during loops. BEWARE: can increase substantially the time to complete the process using a small value, like 10 for instance. Use Inf is no loop message desired.}

\item{res.path}{Character string indicating the absolute pathway where the parallelization log file will be created if parallelization is used. If NULL, will be created in the R current directory.}

\item{lib.path}{Character vector specifying the absolute pathways of the directories containing the required packages if not in the default directories. Ignored if NULL.}

\item{verbose}{Single logical value. Display messages?}

\item{safer.path}{Single character string indicating the absolute path of the safer.R file. Will be remove when safer will be a package. Ignored if parall is FALSE.}
}
\value{
A data frame containing :

- $left : the left boundary of each window (in the unit of the data argument).

- $right : the right boundary of each window (in the unit of data argument).

- $center : the center of each window (in the unit of data argument).

- $value : the computed value by the fun argument in each window).
}
\description{
Return a computation made on a vector using a sliding window.
}
\details{
WARNINGS

The function uses two strategies, depending on the amout of memory required which depends on the data, window.size and step arguments. The first one uses lapply(), is generally fast but requires lots of memory. The second one uses a parallelized loop. The choice between the two strategies is automatic if parall argument is FALSE, and is forced toward parallelization if parall argument is TRUE.

The parall argument forces the parallelization, which is convenient when the data argument is big, because the lapply() function is sometimes slower than the parallelization.

Always use the env argument when slide() is used inside functions.
}
\examples{
slide(data = c(1:10, 100:110, 500), window.size = 5, step = 2, fun = length, boundary = "left")

slide(data = c(1:10, 100:110, 500), window.size = 5, step = 2, fun = length, boundary = "right") # effect of boundary argument

\dontrun{
slide(data = c(1:10, 100:110, 500), window.size = 5, step = 2, fun = length, boundary = "left", parall = TRUE, thread.nb = 2) # effect of parall argument
}
}
